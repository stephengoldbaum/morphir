module Morphir.TypeScript.PrettyPrinter exposing (mapCompilationUnit, mapTypeDef)

{-| This module contains a pretty-printer that takes a TypeScript AST as an input and returns a formatted text
representation.

@docs mapCompilationUnit, mapTypeDef, mapTypeExp

-}

import Elm.Syntax.Expression exposing (Expression(..))
import Morphir.File.SourceCode exposing (Doc, concat, indentLines, newLine)
import Morphir.IR.Path exposing (Path)
import Morphir.TypeScript.AST exposing (CompilationUnit, Expression(..), FunctionScope(..), ImportDeclaration, NamespacePath, Parameter, Privacy(..), Statement(..), TypeDef(..), TypeExp(..))
import Morphir.TypeScript.PrettyPrinter.Expressions exposing (..)


{-| Indent used in pretty printer. Note that we post-process the output with
Prettier (<https://prettier.io/>) so changing this value won't affect the
generated output.
-}
defaultIndent =
    2


{-| -}
mapCompilationUnit : CompilationUnit -> Doc
mapCompilationUnit cu =
    case cu of
        { dirPath, imports, typeDefs } ->
            concat
                [ "// Generated by morphir-elm"
                , newLine ++ newLine
                , imports
                    |> List.map mapImportDeclaration
                    |> String.join newLine
                , newLine ++ newLine
                , typeDefs
                    |> List.map mapTypeDef
                    |> List.map (\mappedTypeDef -> mappedTypeDef ++ newLine ++ newLine)
                    |> String.join newLine
                ]


mapImportDeclaration : ImportDeclaration -> String
mapImportDeclaration { importClause, moduleSpecifier } =
    concat
        [ "import "
        , importClause
        , " from "
        , "\"" ++ moduleSpecifier ++ "\""
        ]


exportIfPublic : Privacy -> String
exportIfPublic privacy =
    case privacy of
        Public ->
            "export "

        Private ->
            ""


{-| Map a type definition to text.
-}
mapTypeDef : TypeDef -> Doc
mapTypeDef typeDef =
    case typeDef of
        Namespace { name, privacy, content } ->
            concat
                [ privacy |> exportIfPublic
                , "namespace "
                , name
                , " {" ++ newLine
                , content
                    |> List.map mapTypeDef
                    |> List.map (\mappedTypeDef -> mappedTypeDef ++ newLine)
                    |> indentLines defaultIndent
                , newLine ++ "}"
                ]

        TypeAlias { name, privacy, doc, variables, typeExpression, decoder, encoder } ->
            let
                docstring =
                    if String.length doc > 0 then
                        String.concat [ "/*", doc, "*/" ]

                    else
                        ""
            in
            concat
                [ docstring
                , newLine
                , privacy |> exportIfPublic
                , "type "
                , name
                , mapGenericVariables variables
                , " = "
                , mapTypeExp typeExpression
                , newLine
                , newLine
                , mapMaybeStatement decoder
                , newLine
                , newLine
                , mapMaybeStatement encoder
                ]

        VariantClass { name, privacy, variables, body, constructor, decoder, encoder } ->
            let
                preface : String
                preface =
                    concat
                        [ privacy |> exportIfPublic
                        , "class "
                        , name
                        , mapGenericVariables variables
                        , " {"
                        ]

                mainbody : List String
                mainbody =
                    [ body |> List.map mapStatement >> String.join newLine
                    , newLine
                    , mapMaybeStatement constructor
                    ]
            in
            concat
                [ preface
                , newLine
                , mainbody |> indentLines defaultIndent
                , "}"
                , newLine
                , newLine
                , mapMaybeStatement decoder
                , newLine
                , newLine
                , mapMaybeStatement encoder
                , newLine
                ]

        ImportAlias { name, privacy, namespacePath } ->
            concat
                [ privacy |> exportIfPublic
                , "import "
                , name
                , " = "
                , namespaceNameFromPackageAndModule (Tuple.first namespacePath) (Tuple.second namespacePath)
                ]


mapExpression : Expression -> String
mapExpression expression =
    case expression of
        ArrayLiteralExpression values ->
            concat
                [ "["
                , String.join ", " (values |> List.map mapExpression)
                , "]"
                ]

        Call { function, arguments } ->
            concat
                [ mapExpression function
                , "("
                , String.join ", " (arguments |> List.map mapExpression)
                , ")"
                ]

        Identifier name ->
            name

        IntLiteralExpression num ->
            String.fromInt num

        IndexedExpression { object, index } ->
            concat
                [ mapExpression object
                , "["
                , mapExpression index
                , "]"
                ]

        MemberExpression { object, member } ->
            concat
                [ mapExpression object
                , "."
                , mapExpression member
                ]

        NewExpression { constructor, arguments } ->
            concat
                [ "new "
                , constructor
                , "("
                , arguments |> List.map mapExpression |> String.join ", "
                , ")"
                ]

        NullLiteral ->
            "null"

        ObjectLiteralExpression { properties } ->
            let
                mapObjectField : ( String, Expression ) -> String
                mapObjectField ( fieldName, fieldValue ) =
                    concat
                        [ fieldName
                        , ": "
                        , fieldValue |> mapExpression
                        ]
            in
            concat
                [ "{"
                , String.join ", " (properties |> List.map mapObjectField)
                , "}"
                ]

        StringLiteralExpression string ->
            concat
                [ "\""
                , string
                , "\""
                ]


mapMaybeStatement : Maybe Statement -> String
mapMaybeStatement maybeStatement =
    case maybeStatement of
        Just statement ->
            mapStatement statement

        Nothing ->
            ""


mapStatement : Statement -> String
mapStatement statement =
    case statement of
        FunctionDeclaration { name, typeVariables, returnType, scope, parameters, body, privacy } ->
            let
                prefaceKeywords : String
                prefaceKeywords =
                    case scope of
                        ModuleFunction ->
                            concat
                                [ privacy |> exportIfPublic
                                , "function "
                                ]

                        ClassStaticFunction ->
                            concat
                                [ "static "
                                ]

                        _ ->
                            ""

                typeVariablesString : String
                typeVariablesString =
                    case typeVariables of
                        [] ->
                            ""

                        _ ->
                            concat
                                [ "<"
                                , String.join ", " (typeVariables |> List.map mapTypeExp)
                                , ">"
                                ]

                returnTypeExpression : String
                returnTypeExpression =
                    case returnType of
                        Nothing ->
                            ""

                        Just typeExp ->
                            concat [ ": ", mapTypeExp typeExp ]
            in
            concat
                [ prefaceKeywords
                , name
                , typeVariablesString
                , "("
                , String.join ", " (parameters |> List.map mapParameter)
                , ")"
                , returnTypeExpression
                , " {"
                , newLine
                , body |> List.map mapStatement |> indentLines defaultIndent
                , newLine
                , "}"
                ]

        ReturnStatement expression ->
            concat [ "return ", mapExpression expression, ";" ]

        LetStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ "let "
                , mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        AssignmentStatement lhsExpression maybeAnnotation rhsExpression ->
            concat
                [ mapExpression lhsExpression
                , mapMaybeAnnotation maybeAnnotation
                , " = "
                , mapExpression rhsExpression
                , ";"
                ]

        ExpressionStatement expression ->
            concat [ mapExpression expression, ";" ]

        SwitchStatement condition cases ->
            let
                mapCase : ( Expression, List Statement ) -> String
                mapCase ( caseExpr, statementList ) =
                    concat
                        [ "case "
                        , mapExpression caseExpr
                        , ":"
                        , statementList |> List.map mapStatement |> indentLines defaultIndent
                        ]
            in
            concat
                [ "switch ("
                , mapExpression condition
                , ") {"
                , newLine
                , cases |> List.map mapCase |> indentLines defaultIndent
                , newLine
                , "}"
                ]
